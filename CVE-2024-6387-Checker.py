import paramiko
import socket
import argparse
import re
from netaddr import IPNetwork
import pandas as pd
from concurrent.futures import ThreadPoolExecutor, as_completed
from termcolor import colored

# Vulnerable OpenSSH versions regex
vulnerable_versions = re.compile(r'OpenSSH_(8\.[5-9]|9\.[0-8])')

def check_ssh_version(host, port):
    try:
        sock = socket.create_connection((host, port), timeout=10)
        banner = sock.recv(1024)
        sock.close()

        try:
            banner_decoded = banner.decode()
        except UnicodeDecodeError:
            banner_decoded = banner.decode(errors='ignore')

        if "OpenSSH" in banner_decoded:
            match = vulnerable_versions.search(banner_decoded)
            if match:
                print(colored(f"[!] {host}:{port} is running a likeley vulnerable OpenSSH version: {banner_decoded.strip()}", 'red'))
            else:
                print(colored(f"[+] {host}:{port} is running a secure OpenSSH version: {banner_decoded.strip()}", 'green'))
        else:
            # Only output the SSH banner without extra data
            ssh_banner = banner_decoded.split('\n')[0]
            print(colored(f"[-] {host}:{port} has SSH open but it's not running OpenSSH: {ssh_banner.strip()}", 'yellow'))

    except socket.timeout:
        pass  # Suppress timeout messages
    except socket.error as e:
        if "Connection refused" not in str(e) and "Permission denied" not in str(e):
            print(f"[-] Could not connect to {host}:{port}: {e}")

def scan_hosts(hosts, port, max_workers=10):
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        futures = {executor.submit(check_ssh_version, host, port): host for host in hosts}
        for future in as_completed(futures):
            host = futures[future]
            try:
                future.result()
            except Exception as e:
                print(f"Error scanning {host}: {e}")

def scan_csv(file_path, max_workers=10):
    try:
        data = pd.read_csv(file_path)
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = {executor.submit(check_ssh_version, row['ip'], row['port']): (row['ip'], row['port']) for index, row in data.iterrows()}
            for future in as_completed(futures):
                host, port = futures[future]
                try:
                    future.result()
                except Exception as e:
                    print(f"Error scanning {host}:{port}: {e}")
    except FileNotFoundError:
        print(f"File {file_path} not found.")
    except Exception as e:
        print(f"Error reading {file_path}: {e}")

def main():
    parser = argparse.ArgumentParser(description='Scan network for vulnerable OpenSSH versions.')
    parser.add_argument('input', help='Host(s) to scan (single IP, comma-separated, CIDR, or file path)')
    parser.add_argument('-p', '--port', type=int, default=22, help='SSH port (default: 22)')
    parser.add_argument('-c', '--csv', action='store_true', help='Input is a CSV file with IP and port columns')
    parser.add_argument('-w', '--workers', type=int, default=10, help='Number of concurrent workers (default: 10)')

    args = parser.parse_args()

    if args.csv:
        scan_csv(args.input, args.workers)
    else:
        input_data = args.input

        if '/' in input_data:  # CIDR notation
            hosts = [str(ip) for ip in IPNetwork(input_data)]
        elif ',' in input_data:  # Comma-separated list
            hosts = input_data.split(',')
        elif '.' in input_data and len(input_data.split('.')) == 4:  # Single IP address
            hosts = [input_data]
        else:  # Assume it's a file
            try:
                with open(input_data, 'r') as file:
                    hosts = [line.strip() for line in file if line.strip()]
            except FileNotFoundError:
                print(f"File {input_data} not found.")
                return

        scan_hosts(hosts, args.port, args.workers)

if __name__ == "__main__":
    main()

